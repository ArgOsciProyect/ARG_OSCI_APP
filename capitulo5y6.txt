Capítulo 5: Arquitecturas y patrones de diseño: 
5.1 Pipeline design Pattern: 
El Pipeline Design Pattern es un patrón de diseño que se basa en dividir el procesamiento de datos en una secuencia ordenada de etapas cada una encargada de realizar una transformación o validación específica sobre la información que recibe, permitiendo que cada componente actúe de forma independiente y se conecte al siguiente, formando un flujo continuo que facilita tanto la escalabilidad como el mantenimiento del sistema.
El fundamento principal es la idea de que para una entrada cada etapa aplica una operación determinada y produce una salida que se convierte en la entrada de la etapa siguiente. Esto se puede implementar de forma síncrona o asíncrona, la separación de responsabilidades en cada etapa reduce el acoplamiento entre los componentes.
Esta estructura favorece la incorporación escalonada de validaciones y transformaciones. Por ejemplo, en un flujo de datos la etapa inicial puede filtrar información irrelevante, mientras que las posteriores se encargan de convertir formatos, realizar cálculos específicos o aplicar transformaciones adicionales, esto facilita el testing ya que cada etapa se puede probar de forma aislada antes de integrarse en el flujo global.
5.2 Observer Design Pattern
El Observer design pattern define una relación uno a muchos entre un sujeto y múltiples observadores, de esta forma, cuando el sujeto experimenta un cambio en su estado, notifica automáticamente a todos los observadores registrados mediante la ejecución de un método de actualización definido en cada uno. Esta notificación se puede implementar de forma que el sujeto envíe información detallada sobre el cambio o que se permita que cada observador consulte el estado actual del sujeto de forma independiente. La estructura resultante favorece un acoplamiento débil entre los componentes, facilitando que los observadores reaccionen de forma autónoma a los eventos sin depender de la implementación interna del sujeto. Este patrón es muy útil en sistemas basados en eventos y en arquitecturas donde se requiere que la interfaz de usuario se actualice de manera dinámica ante cambios en el modelo.

5.3 Strategy Design Pattern
El Strategy Design Pattern es un patrón de diseño de comportamiento que permite definir una familia de algoritmos, encapsular cada uno de ellos y hacerlos intercambiables, tiene como objetivo separar el algoritmo del contexto, de forma que la implementación concreta de la estrategia pueda variar sin modificar el cliente que la utiliza, posibilitando cambiar el comportamiento de un objeto en tiempo de ejecución mediante la selección de la estrategia más adecuada para cada situación. Su implementación consiste en una interfaz común que declara los métodos necesarios para ejecutar la estrategia, obligando a cada implementación concreta a adherirse a dicho contrato.
El Strategy Design Pattern reduce el acoplamiento entre el contexto y las implementaciones de los algoritmos, flexibilizando y facilitando el mantenimiento al código, ya que al aislar la lógica de cada estrategia, se permite su prueba individual y se asegura que la modificación o sustitución de un algoritmo específico no afecte el funcionamiento global del sistema.
5.4 Repository Design Pattern
El Repository Design Pattern es un patrón de diseño que se encarga de abstraer y centralizar el acceso a datos en la capa externa de la aplicación, permitiendo que el dominio se mantenga completamente desacoplado de las implementaciones concretas de persistencia al exponer una interfaz fuertemente tipada y orientada a objetos para realizar operaciones de lectura, escritura, actualización y eliminación de información facilitando tanto la migración entre diferentes fuentes de datos como la incorporación de nuevas tecnologías sin afectar la lógica de negocio. Este patrón puede implementarse con la definición de contratos mediante interfaces o clases abstractas que declaran los métodos necesarios para interactuar con el almacenamiento, obligando a cada repositorio a adherirse a dichos contratos. Se crea una separación clara entre la lógica del dominio y las operaciones de persistencia, lo que favorece la realización de pruebas unitarias al permitir el uso de mocks para simular el acceso a datos. Este patrón también facilita migraciones o cambios en la infraestructura, ya que encapsula todas las particularidades del medio de almacenamiento en un único componente, evitando que dichas modificaciones repercutan en el núcleo de la aplicación.

5.5 Clean Architecture
Es una arquitectura de software que se encarga de separar de forma estricta las responsabilidades dentro de una aplicación para preservar el núcleo de la lógica de negocio de las dependencias externas, aislando el dominio del resto de la aplicación, lo que permite que cambios en la infraestructura, en la interfaz de usuario o en la forma de persistir los datos no afecten la estabilidad ni la integridad del sistema.
En esta arquitectura se establece una división en capas, donde la capa central contiene las entidades y casos de uso que representan la lógica del dominio y se comunica únicamente a través de contratos fuertemente tipados, las capas externas incluyen desde la presentación hasta el acceso a datos y se integran mediante adaptadores que realizan la transformación necesaria sin revelar detalles internos. 


Figura 12: Representación gráfica de la Clean Architecture (Fuente: https://dev.to/dazevedo/series/29056 [10])

La implementación de Clean Architecture se basa en la inversión de dependencias esto implica que las capas externas dependen de abstracciones definidas en el núcleo y no al revés.



Capítulo 6: Organización de la Estructura de Carpetas para Aplicaciones Flutter
6.1 Contexto
La organización escalable de carpetas para aplicaciones Flutter se basa en la idea de segmentar el código en módulos independientes, donde cada carpeta asume una responsabilidad específica. Esta división permite que cada componente se desarrolle, se pruebe y se mantenga de forma aislada, lo que contribuye a reducir el acoplamiento y a potenciar la escalabilidad del sistema. 
6.2 Patrones de Organización
Tenemos dos patrones principales:
Folders By Type/Domain:
Organiza los archivos según su tipo (por ejemplo, screens, models, widgets). Este patrón es intuitivo para proyectos pequeños, pero al incrementarse la cantidad de archivos, se vuelve difícil de mantener.
Folders By Feature:
Organiza el código según las funcionalidades. Cada carpeta de feature reúne los archivos relacionados (pantallas, widgets, modelos, servicios, view_models, etc.), lo que favorece el manejo en proyectos de mayor escala.
6.3 Ejemplo de Estructura por Feature
La estructura generada para el patrón por feature es la siguiente:
En esta estructura:
Domain → Models: Contiene los modelos de datos y funciones para conversión JSON.
Domain → Repository: Define clases abstractas que describen la funcionalidad de la feature.
Domain → Services: Implementa los repositorios.
Providers: Reúne la lógica de estado.
Screens: Almacena pantallas completas.
Widgets: Incluye componentes reutilizables.
Cada carpeta dispone de un archivo de exportación para simplificar las importaciones. [16]

Figura N: Descripción gráfica de la estructura de carpetas (Fuente: Propia, basado en [16])
