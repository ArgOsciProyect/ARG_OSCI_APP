Capítulo 7: Comunicación
Este capítulo abarca el desarrollo realizado para establecer la comunicación entre la ESP32–S y el dispositivo donde se ejecute la aplicación ARG OSCI.
Primero se trató sobre la decisión de utilizar Wi-Fi sobre otros medios de comunicación como bluetooth o USB-OTG y las pruebas realizadas en este campo.
Luego, sobre porqué se eligió TCP sobre UDP para la transmisión de los datos adquiridos y HTTP para la transmisión de datos de control.
Finalmente, se desarrollará como se implementaron las conexiones iniciales, el manejo de errores en la conexión y el intercambio de credenciales para conectividad con un Access Point externo.
7.1 Selección del medio de comunicación
7.1.1 Análisis comparativo
La elección del medio de comunicación se fundamenta en el análisis comparativo de 4 medios diferentes de comunicación para alcanzar la tasa de transmisión requerida para transmitir los datos adquiridos de forma constante, la cual en un principio fue de 4 MB/s teniendo en cuenta la capacidad de transmisión, la flexibilidad operativa y la integridad de la señal. Se evaluaron alternativas tales como Wi-Fi, Bluetooth Low Energy, Bluetooth Classic y USB. 
La tasa de transmisión necesaria para poder enviar la totalidad de los datos adquiridos y que la transmisión no sea un cuello de botella es de 5MB/s, esto se debe a que la frecuencia de muestreo del ADC es de 2,5 MSamples/s en la configuración de ADC externo, por lo que se deben transmitir 2 bytes de datos por cada muestra.
En el caso de las tecnologías Bluetooth se consideraron ambas variantes (tanto Bluetooth Low Energy como Bluetooth Classic) dada su integración nativa en la plataforma ESP32. No obstante, espressif indica que la tasa de transferencia de datos de Bluetooth Low Energy se encuentra limitada a aproximadamente 90 KB/s, mientras que el Bluetooth clásico, si bien puede ofrecer una mayor velocidad (Aproximadamente el doble), igualmente se encuentra enormemente lejos de la tasa necesaria, además cabe considerar que estos valores son teóricos, por lo que es probable que en la práctica los valores sean peores si las condiciones no son las óptimas. [20][26]
Por otro lado, la opción de utilizar la conexión USB-OTG fue descartada debido a que su empleo implicaría la necesidad de una conexión física, lo que restringe la operatividad remota y compromete la aislación galvánica entre los equipos involucrados, como el osciloscopio y el dispositivo de visualización, además de solo estar disponible para modelos de ESP32-S2 en adelante.[21]
7.1.2 Pruebas de rendimiento de Wi-Fi
El hecho de descartar Bluetooth y USB-OTG deja claro que Wi-Fi es la mejor opción para lograr una velocidad de transferencia más cercana a la ideal. [22]
Sin embargo, Wi-Fi presenta un desafío: La utilización de un AP creado por la ESP32 como forma de conexión deja al usuario sin acceso a internet por este medio, lo que puede ser un incordio en muchas situaciones, más adelante se detallara cómo se afrontó este desafío.
Para afirmar que Wi-Fi es la mejor opción, se hicieron pruebas de su rendimiento (Primero utilizando el AP de la ESP32 y posteriormente un AP externo) y se obtuvieron los resultados de la figura N:

Figura N: Resultados estadísticos de la tasa de transferencia por Wi-Fi (Fuente: Propia)

Los resultados experimentales revelan que, en condiciones reales, la tasa de transmisión obtenida se encuentra significativamente por debajo del umbral requerido de 5 MB/s.
En el caso de utilizar un AP interno (configurado por la ESP32), se registraron tasas medias consistentes alrededor de 1.41–1.44 MB/s, con fluctuaciones relativamente contenidas (Desviación Estándar de 0.11–0.15 MB/s) y mínimos que en algunas pruebas descendieron hasta 0.58 MB/s. Estos valores, si bien son superiores a los alcanzados con las otras configuraciones, evidencian que el rendimiento efectivo sigue siendo insuficiente para el caudal teórico requerido. A su vez, la utilización de un AP externo redujo drásticamente el rendimiento, obteniéndose tasas medias de aproximadamente 0.50–0.51 MB/s, con mínimos aún más bajos (en ocasiones hasta 0.08 MB/s). Asimismo, la conectividad usando el AP interno desde un teléfono celular (Samsung Galaxy S10e) demostró un rendimiento aún inferior, con tasas medias en el rango de 0.39–0.45 MB/s y mayor dispersión en las mediciones.
Si bien la elección de Wi-Fi es la única alternativa que podría acercarse a la tasa de transmisión necesaria (ya que, incluso en las peores condiciones, se alcanza el doble de lo que Bluetooth podría ofrecer), las mediciones indican que la implementación actual no cumple con los requerimientos del sistema. Por ello, se vuelve un requisito del producto garantizar su operatividad independientemente de la tasa de transmisión, la cual afectará únicamente la calidad de la experiencia pero no su funcionalidad básica.
7.2 Selección de protocolos de comunicación
La elección de los protocolos de comunicación se realizó considerando dos aspectos fundamentales del sistema: la transmisión continua de datos del ADC y el envío de comandos de control. Para el primer caso se optó por TCP, mientras que para el segundo se implementó HTTP.
7.2.1 TCP para transmisión de datos
La decisión de utilizar TCP para la transmisión de datos del ADC, a pesar de su mayor overhead comparado con UDP, se fundamenta en los siguientes aspectos:
Primero, la integridad y orden de los datos es fundamental para el correcto funcionamiento del sistema de triggers. El sistema utiliza una ventana deslizante de datos para detectar flancos y calcular cruces por nivel, por lo que un dato corrupto o faltante podría causar detecciones erróneas. Por ejemplo, si un paquete contiene valores cercanos al nivel de trigger configurado, su pérdida o corrupción podría resultar en triggers falsos o pérdida de eventos válidos, esta situación es aún peor cuando el modo single shot se encuentra activo, ya que se podría perder el paquete con el transitorio que se quiere observar.
Segundo, en el cálculo de métricas como frecuencia y valores pico el programa
depende crucialmente de tener una secuencia completa y ordenada de datos. El sistema calcula la frecuencia analizando los intervalos entre triggers consecutivos - un paquete perdido podría resultar en una medición de frecuencia errónea. Los valores máximos y mínimos se utilizan tanto para el autoescalado como para ajustar la sensibilidad del trigger, por lo que datos incorrectos afectarían múltiples aspectos de la visualización. [24]
Concluyendo, aunque la tasa de transferencia alcanzada está por debajo de la ideal, la confiabilidad que ofrece TCP es más valiosa que la potencial ganancia en velocidad que podría ofrecer UDP. Tanto el software como el firmware están diseñados para funcionar con tasas de muestreo reducidas, por lo que es preferible garantizar la integridad de los datos disponibles que arriesgar su corrupción por usar un protocolo no confiable. Si bien se podría aplicar una lógica en capa de aplicación para evitar los inconvenientes de UDP, se consideró más eficiente utilizar directamente TCP para la transmisión de los datos.
7.2.2 Http para control.
Para la comunicación de control se implementó HTTP por varias razones:
La arquitectura REST facilita la implementación de nuevas funcionalidades mediante endpoints adicionales. Por ejemplo, el sistema actual incluye endpoints para configuración de trigger en hardware, control de modo de operación, ajuste de frecuencia de muestreo, configuración de red, entre otros. El protocolo HTTP proporciona una estructura clara para el manejo de errores y estados, crucial para operaciones como la configuración inicial del dispositivo y la gestión de conexiones Wi-Fi. Cada endpoint puede devolver códigos de estado específicos que la aplicación utiliza para manejar diferentes situaciones de error y mostrar retroalimentación apropiada al cliente. 
Otro aspecto muy importante es la naturaleza stateless de HTTP que simplifica el manejo de múltiples conexiones y reconexiones, común en entornos donde la conectividad puede ser intermitente como en el uso de un AP externo. [23]

7.3 Implementación del sistema de comunicación
7.3.1 Arquitectura del sistema 
La comunicación entre el dispositivo y la aplicación se basa en una arquitectura distribuida que separa la transmisión de datos del control, optimizando el rendimiento y la fiabilidad.
En el dispositivo, se utilizan dos servidores HTTP en puertos distintos (80 y 81) para asegurar una vía de control constante, independientemente del modo de operación. El servidor en el puerto 81 gestiona la configuración inicial, el establecimiento de conexiones a puntos de acceso externos y el control en modo de punto de acceso interno. El servidor en el puerto 80, por otro lado, se encarga del control en modo de punto de acceso externo. La configuración de la red Wi-Fi se realiza mediante funciones específicas que establecen el modo (punto de acceso, estación o ambos) y los parámetros de la red, como el SSID, la contraseña y el número máximo de clientes.

Al inicio, se generan claves RSA para cifrar las credenciales Wi-Fi, garantizando que no se transmitan en texto plano. La clave pública se usa para cifrar las credenciales en la aplicación, mientras que la clave privada se usa para descifrarlas en el dispositivo. Un semáforo sincroniza la generación de claves con el resto del programa, asegurando su disponibilidad antes de establecer la conexión Wi-Fi. La configuración del punto de acceso se define estableciendo el SSID, la contraseña y el número máximo de conexiones. Para conectarse a una red Wi-Fi externa, se utilizan funciones específicas con los parámetros correspondientes al modo estación, iniciando el proceso de conexión.

Figura N+1: Diagrama de secuencia de la interacción APLICACION-ESP32.
(Fuente: Propia)
7.3.2 Gestión de sockets.
El manejo de sockets se centra en una tarea que crea, enlaza, escucha y acepta conexiones TCP. El socket se crea especificando la familia de direcciones (IPv4), el tipo de socket (TCP) y el protocolo. Se enlaza a una dirección IP y un puerto, asignado dinámicamente por el sistema operativo y obtenido después de enlazar el socket. Este puerto se envía a la aplicación como parte de la respuesta JSON. Posteriormente, se pone en modo de escucha, indicando el número máximo de conexiones entrantes que se pueden encolar. Cuando un cliente se conecta, se crea un nuevo socket para la conexión, permitiendo la gestión de múltiples conexiones simultáneamente (limitado a uno). Finalmente, se utiliza la función send() para enviar los datos al cliente. La tarea se ejecuta en un núcleo específico del procesador, garantizando que la transmisión de datos no se vea afectada por otras tareas.
El cierre de los sockets se realiza de forma segura, intentando primero un cierre elegante, enviando una señal de cierre al cliente y esperando a que se complete la transmisión de los datos pendientes. Esto se logra configurando una opción en el socket que especifica un tiempo de espera para el cierre. Si el cierre elegante falla, la función fuerza el cierre del socket, garantizando que los recursos se liberen de forma oportuna. 
7.3.3 Configuración de conectividad
La configuración del dispositivo en modo de punto de acceso interno se gestiona obteniendo la información IP del punto de acceso, creando y enlazando un socket, y enviando una respuesta con la información de la conexión. En la aplicación, esta conexión se inicia al seleccionar "Local AP" en el diálogo de selección de modo AP. La conexión a una red Wi-Fi externa se gestiona recibiendo las credenciales Wi-Fi cifradas, descifrándolas utilizando la clave privada RSA, configurando el dispositivo para conectarse a la red Wi-Fi externa y esperando a que se establezca la conexión. En la aplicación, este proceso se inicia al seleccionar "External AP" en el diálogo de selección de modo AP.
Una vez que el usuario selecciona una red Wi-Fi externa, la aplicación cifra las credenciales utilizando la clave pública RSA obtenida previamente del dispositivo y las envía. El dispositivo descifra las credenciales y se conecta a la red Wi-Fi externa.

Figura N+1: Impresión de las claves generadas por la ESP32 a través del puerto serie. (Fuente: Propia)

Después de que el dispositivo se conecta a la red Wi-Fi externa, la aplicación espera a que obtenga una dirección IP. Una vez que se obtiene la dirección IP, la aplicación crea un nuevo socket y envía una respuesta con la información de la conexión.


Figura N+2: La ESP32 recibe la contraseña cifrada y se conecta a la red seleccionada.


7.3.4 Estructura de comunicación y adquisición de datos de la aplicación
La aplicación se estructura en tres capas que operan de forma asíncrona: la capa base de comunicación, la capa de procesamiento y la capa de presentación. La capa base de comunicación implementa dos servicios: el SocketService y el HttpService.

El SocketService se encarga de manejar la conexión TCP para la transmisión de los datos. Para garantizar la resiliencia del sistema, si la conexión TCP se interrumpe, el SocketService intenta reconectarse automáticamente.

El HttpService gestiona las comunicaciones de control. Este servicio proporciona manejo automático de sesiones HTTP independientes, un sistema de reintentos configurable, parseo y validación automática de respuestas JSON y timeouts adaptables.

La capa de procesamiento utiliza un sistema de doble isolate para separar la comunicación del procesamiento de datos. Los Isolates permiten ejecutar código en paralelo, sin compartir memoria con el hilo principal de la aplicación. Esto evita que las operaciones de comunicación bloqueen la interfaz de usuario. La comunicación entre los isolates se realiza mediante puertos de envío y recepción, el puerto de envío del SocketIsolate se pasa al ProcessingIsolate durante la inicialización. El ProcessingIsolate utiliza este puerto de envío para enviar los datos recibidos del socket.

El SocketIsolate se dedica a la comunicación TCP. Este isolate implementa recepción y buffering de datos, detección de desconexiones y reconexión automática, monitoreo de métricas de transmisión y control de flujo adaptativo. La comunicación entre los Isolates se realiza mediante un sistema de colas con control de flujo. Este sistema previene desbordamientos de memoria y garantiza la sincronización de los datos procesados. Los datos recibidos por el SocketIsolate se encolan y se envían al ProcessingIsolate para su procesamiento.

El ProcessingIsolate se encarga de procesar los datos recibidos del SocketIsolate. Este isolate implementa la lógica de filtrado, trigger y cálculo de métricas. La comunicación entre el ProcessingIsolate y la capa de presentación se realiza mediante Streams, permitiendo que la interfaz de usuario se actualice de forma reactiva.
